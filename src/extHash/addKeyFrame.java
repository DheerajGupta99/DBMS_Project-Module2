/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package extHash;
//import static extHash.addKeyFrame.DEBUG;
import static extHash.allFrames.mf;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import javax.swing.JOptionPane;

/**
 *
 * @author VISHNUV
 */
public class addKeyFrame extends javax.swing.JFrame implements allFrames{

    public int key=0;
    public String value = "";
    Directory directory = new Directory(mf.bucketSize,mf.gd,mf.ld);
    public static boolean DEBUG = false;
    /**
     * Creates new form addKeyFrame
     */
    public addKeyFrame() {
        initComponents();
        System.gc();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainHeading = new javax.swing.JLabel();
        chooseActionLabel = new javax.swing.JLabel();
        selectComboBox = new javax.swing.JComboBox<>();
        enterKeyLabel = new javax.swing.JLabel();
        keyText = new javax.swing.JTextField();
        akfSubmitBtn = new javax.swing.JButton();
        kerr = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        mainHeading.setFont(new java.awt.Font("Tahoma", 3, 24)); // NOI18N
        mainHeading.setText("Extendible Hashing");

        chooseActionLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        chooseActionLabel.setText("Choose Action");

        selectComboBox.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        selectComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Insert", "Remove", "Search" }));
        selectComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                selectComboBoxItemStateChanged(evt);
            }
        });
        selectComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectComboBoxActionPerformed(evt);
            }
        });

        enterKeyLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        enterKeyLabel.setText("Enter Key");

        keyText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                keyTextActionPerformed(evt);
            }
        });

        akfSubmitBtn.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        akfSubmitBtn.setText("Submit");
        akfSubmitBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                akfSubmitBtnActionPerformed(evt);
            }
        });

        kerr.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        kerr.setForeground(new java.awt.Color(255, 51, 0));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(132, Short.MAX_VALUE)
                .addComponent(mainHeading, javax.swing.GroupLayout.PREFERRED_SIZE, 305, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(85, 85, 85))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(54, 54, 54)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(enterKeyLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(chooseActionLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 115, Short.MAX_VALUE))
                        .addGap(51, 51, 51)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(selectComboBox, 0, 118, Short.MAX_VALUE)
                            .addComponent(keyText))
                        .addGap(31, 31, 31)
                        .addComponent(kerr, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(152, 152, 152)
                        .addComponent(akfSubmitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mainHeading, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(55, 55, 55)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(selectComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(chooseActionLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(37, 37, 37)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(keyText, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(enterKeyLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(38, 38, 38)
                        .addComponent(kerr, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 82, Short.MAX_VALUE)
                .addComponent(akfSubmitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(24, 24, 24))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void selectComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_selectComboBoxItemStateChanged
        // TODO add your handling code here:
    }//GEN-LAST:event_selectComboBoxItemStateChanged

    private void selectComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectComboBoxActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_selectComboBoxActionPerformed

    private void keyTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_keyTextActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_keyTextActionPerformed

    private void akfSubmitBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_akfSubmitBtnActionPerformed
        // TODO add your handling code here:
        boolean flag=true;
        of.textArea.setText(null);
        try{
            key = Integer.parseInt(keyText.getText());
            if(key<0){
                kerr.setText("Enter a +ve integer!");
                flag=false;
            }
        }catch(NumberFormatException e){
            kerr.setText("Enter a +ve integer!");
            flag=false;
        }
        if(flag){
            String s = (String) selectComboBox.getSelectedItem();
            if(s.charAt(0)=='I'){
                //value = valueText.getText();
                directory.insert(key, value);
            }
            else if(s.charAt(0)=='R'){
                directory.remove(key);
                of.textArea.append(key+" is removed!\n");
            }
            else{
                if(directory.lookup(key)!=null){
                    String stringHash = directory.getStringHash(key);
                    //System.out.println(stringHash);
                    of.textArea.append("Key \""+key+"\" found in "+stringHash+" bucket.\n");
                }
                else
                    of.textArea.append("Key "+key+" not found!"+"\n");
                
            }
            of.textArea.append("\n\nCurrent state of the Directory: "+"\n\n");
            of.textArea.append(directory.toString()+"\n");
            keyText.setText(null);
            //valueText.setText(null);
            of.hfLabel.setText("Hash Function: h(K) = K mod "+mf.hashFunc);
            of.bsLabel.setText("Bucket Size: " + mf.bucketSize);
            this.setVisible(false);
            of.setVisible(true);
        }
    }//GEN-LAST:event_akfSubmitBtnActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(addKeyFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(addKeyFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(addKeyFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(addKeyFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                mf.akf.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton akfSubmitBtn;
    private javax.swing.JLabel chooseActionLabel;
    private javax.swing.JLabel enterKeyLabel;
    private javax.swing.JLabel kerr;
    private javax.swing.JTextField keyText;
    private javax.swing.JLabel mainHeading;
    private javax.swing.JComboBox<String> selectComboBox;
    // End of variables declaration//GEN-END:variables


}


class Directory implements allFrames{
    private int depth;
    private int bucketSize;
    private Bucket[] buckets;
    private HashMap<String, Bucket> bucketMap;

    public int getDepth() {
        return this.depth;
    }

    public void setDepth(int depth) {
        this.depth = depth;
    }

    public Directory depth(int depth) {
        this.depth = depth;
        return this;
    }

    public int getBucketSize() {
        return this.bucketSize;
    }

    public void setBucketSize(int bucketSize) {
        this.bucketSize = bucketSize;
    }

    public Directory bucketSize(int bucketSize) {
        this.bucketSize = bucketSize;
        return this;
    }

    public Bucket[] getBuckets() {
        return this.buckets;
    }

    public void setBuckets(Bucket[] buckets) {
        this.buckets = buckets;
    }

    public Directory buckets(Bucket[] buckets) {
        this.buckets = buckets;
        return this;
    }

    public HashMap<String, Bucket> getBucketMap() {
        return this.bucketMap;
    }

    public void setBucketMap(HashMap<String, Bucket> bucketMap) {
        this.bucketMap = bucketMap;
    }

    public Directory bucketMap(HashMap<String, Bucket> bucketMap) {
        this.bucketMap = bucketMap;
        return this;
    }

    public Directory(int bucketSize,int gd,int ld) {
        this.bucketSize = bucketSize;
        //int n=(int)Math.pow(2, gd);
        bucketMap = new HashMap<>();
        bucketMap.put("0", new Bucket().size(bucketSize).depth(1).pattern("0"));
        bucketMap.put("1", new Bucket().size(bucketSize).depth(1).pattern("1"));
        /*for(int i=0;i<n;i++){
            String h=HashGenerator.hash(i).substring(8 - gd, 8);
            //System.out.println(h);
            bucketMap.put(h, new Bucket().size(bucketSize).depth(ld).pattern(h));
        }*/
        
        /*int y=(int)Math.pow(2, ld),x=(int)Math.pow(2, gd-ld);
        for(int i=0;i<y;i++){
            String h=HashGenerator.hash(i).substring(8 - gd, 8);
            String h1=HashGenerator.hash(i).substring(8 - ld, 8);
            bucketMap.put(h, new Bucket().size(bucketSize).depth(ld).pattern(h));
            for(int j=1;j<x;j++){
                String h2=HashGenerator.hash(j).substring(8 - gd, 8-ld)+h1;
                //bucketMap.put(h2, getBucketMap().get(h));
                bucketMap.put(h2, getBucketMap().get(h));
                //getBucketMap().put(h2,getBucketMap().get(h));
            }
        }*/
        
        /*int y=(int)Math.pow(2, ld),x=(int)Math.pow(2, gd-ld);
        if(gd>ld){
            for(int i=0;i<y;i++){
                String h=HashGenerator.hash(i).substring(8 - gd, 8);
                String h1=HashGenerator.hash(i).substring(8 - ld, 8);
                Bucket temp = getBucketMap().get(h);
                for(int j=1;j<x;j++){
                    String h2=h1+HashGenerator.hash(j).substring(8 - gd, 8-ld);
                    Bucket temp2 = getBucketMap().get(h2);
                }
            }
        }*/
        depth = gd;
    }

    private void splitBucket(Bucket bucketToBeSplit){
        int currentDepth = bucketToBeSplit.getDepth();
        String currentPattern = bucketToBeSplit.getPattern();
        Bucket firstBucket = new Bucket().depth(currentDepth + 1).pattern("0" + currentPattern)
                .size(bucketToBeSplit.getSize());
        Bucket secondBucket = new Bucket().depth(currentDepth + 1).pattern("1" + currentPattern)
                .size(bucketToBeSplit.getSize());
        bucketMap.put(firstBucket.getPattern(), firstBucket);
        bucketMap.put(secondBucket.getPattern(), secondBucket);
        bucketToBeSplit.getData()
                .forEach((dataKey, dataValue) -> bucketMap.get(getStringHash(dataKey)).insert(dataKey, dataValue));
    }

    private void expandDirectory(){

        List<String> keys = new ArrayList<>(bucketMap.keySet());

        keys.forEach(key -> {
            Bucket pointedBucket = bucketMap.get(key);
            bucketMap.put("1" + key, pointedBucket);
            bucketMap.put("0" + key, pointedBucket);
            bucketMap.remove(key);
        });
        depth++;
    }

    private String getSisPattern(String pattern) {
        // return pattern.substring(0, pattern.length() - 1) +
        // (pattern.charAt(pattern.length() - 1) == '1' ? "0" : "1");
        return (pattern.charAt(0) == '1' ? "0" : "1") + pattern.substring(1, pattern.length());
    }

    private Bucket getBucketByPattern(String pattern) {
        return getBucketMap().values().stream().filter(bucket -> bucket.getPattern().equals(pattern)).findFirst()
                .orElse(null);
    }

    private boolean checkIfMergeNeeded(Bucket bucket) {
        if (bucket.getPattern().length() > 1) {
            String sisPattern = getSisPattern(bucket.getPattern());
            Bucket sisBucket = getBucketByPattern(sisPattern);
            if (sisBucket == null)
                return false;
            return (bucket.getData().size() + sisBucket.getData().size() <= bucketSize);
        }
        return false;
    }

    private void mergeBuckets(Bucket bucket) {
        String pattern = bucket.getPattern();
        String sisPattern = getSisPattern(pattern);
        Bucket sisBucket = getBucketByPattern(sisPattern);
        String newPattern = bucket.getPattern().substring(1, pattern.length());
        HashMap<Integer, String> newData = new HashMap<>();
        newData.putAll(bucket.getData());
        newData.putAll(sisBucket.getData());
        Bucket newBucket = new Bucket().pattern(newPattern).depth(bucket.getDepth() - 1).size(this.bucketSize)
                .data(newData);
        bucketMap.forEach((key, value) -> {
            if (value == bucket || value == sisBucket)
                bucketMap.put(key, newBucket);
        });
    }

    private boolean checkIfShrinkRequired() {
        return !bucketMap.values().stream().distinct().anyMatch(bucket -> bucket.getDepth() == this.depth);
    }

    private void shrinkTable() {
        List<String> keys = new ArrayList<>(bucketMap.keySet());

        keys.forEach(key -> {
            if (bucketMap.get(key) != null) {
                String sisKey = getSisPattern(key);
                String newKey = key.substring(1, key.length());
                bucketMap.put(newKey, bucketMap.get(key));
                bucketMap.remove(key);
                bucketMap.remove(sisKey);
            }
        });
        depth--;
        if (checkIfShrinkRequired())
            shrinkTable();
    }

    public String getStringHash(int key) {
        String s = "";
        try{
            s=HashGenerator.hash(key).substring(8 - depth, 8);
        } catch(Exception e){
            System.out.println("You cannot proceed from now on!! Bye!");
        }
        return s;
    }

    public void insert(int key, String value) {
        String stringHash = getStringHash(key);
        if (mf.akf.DEBUG){
            //System.out.println("The value of hash is: " + stringHash);
            of.textArea.append("The value of hash is: "+stringHash+"\n");
        }
        Bucket bucket = bucketMap.get(stringHash);

        if (bucket.insert(key, value)) {
            if (mf.akf.DEBUG){
                //System.out.println("The value has been inserted.");
                of.textArea.append("The value has been inserted."+"\n");
            }
        } else {
            if (bucket.getDepth() < this.depth) {
                if (mf.akf.DEBUG)
                    //System.out.println("The bucket has a depth level less than global depth, bucket needs to be split");
                    of.textArea.append("The bucket has a depth level less than global depth, bucket needs to be split"+"\n");
                try{
                    splitBucket(bucket);
                    insert(key, value);
                } catch(Exception e){
                    //System.out.println("Overflown!");
                    JOptionPane.showMessageDialog(null,"Bucket Overflown! \n CLOSING APP!");
                    System.exit(0);
                }
                //splitBucket(bucket);
                //insert(key, value);
            } else if (bucket.getDepth() == this.depth) {
                if (mf.akf.DEBUG)
                    /*System.out.println(
                            "The bucket has a depth level equal to the global depth, both bucket and directory needs to be split and extended.");*/
                    of.textArea.append("The bucket has a depth level equal to the global depth, both bucket and directory needs to be split and extended."+"\n");
                try{
                    expandDirectory();
                    splitBucket(bucket);
                    insert(key, value);
                } catch(Exception e){
                    //System.out.println("Overflown!!");
                    JOptionPane.showMessageDialog(null,"Bucket Overflown!!");
                    System.exit(0);
                }
                //expandDirectory();
                //splitBucket(bucket);
                //insert(key, value);
            } else {
                if (mf.akf.DEBUG)
                    /*System.out.println(
                            "The bucket has a depth level greater than global depth which is not possible. Exiting the program.");*/
                    of.textArea.append("The bucket has a depth level greater than global depth which is not possible. Exiting the program."+"\n");
                System.exit(-1);
            }
        }

    }

    public String lookup(int key) {
        String stringHash = getStringHash(key);
        Bucket bucket = bucketMap.get(stringHash);
        if (bucket.getData().get(key) == null)
            return null;
        return Optional.of(bucket.getData().get(key)).orElse(null);

    }

    public void remove(int key) {
        String stringHash = getStringHash(key);
        Bucket bucket = bucketMap.get(stringHash);
        if (bucket != null) {
            bucket.getData().remove(key);
            if (checkIfMergeNeeded(bucket)) {
                mergeBuckets(bucket);
                if (checkIfShrinkRequired())
                    shrinkTable();
            }
        }
    }

    // @Override
    // public String toString() {
    // return "Directory [bucketMap=" + bucketMap + ", bucketSize=" + bucketSize +
    // ", buckets="
    // + Arrays.toString(buckets) + ", depth=" + depth + "]";
    // }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        List<String> keys = new ArrayList<>(getBucketMap().keySet());
        Collections.sort(keys);
        for (String key : keys) {
            //System.out.println(key);
            if (!builder.toString().contains(key + ":")) {
                builder.append(key + ": ───────────── ");
                Bucket temp = getBucketMap().get(key);
                if (temp != null) {
                    builder.append(temp.toString() + System.lineSeparator());

                    keys.stream().filter(tempKey -> !tempKey.equals(key))
                            .filter(tempKey -> getBucketMap().get(tempKey) == temp)
                            .forEach(tempKey -> builder.append(tempKey + ": ┘" + System.lineSeparator()));

                    builder.append(System.lineSeparator());
                } else
                    builder.append(System.lineSeparator());
            }
        }

        return "(GD: " + getDepth() + ")" + System.lineSeparator() + System.lineSeparator()
                + builder.toString();
    }

}

class HashGenerator {

    public static String hash(int key) {
        key=key%(mf.hashFunc);
        String value = Integer.toBinaryString(key);
        for (int i = value.length(); i < 8; i++) {
            value = "0" + value;
        }
        return value;
    }
}

class Bucket {
    private int depth;
    private int size;
    private String pattern;
    private HashMap<Integer, String> data;

    public Bucket() {
        data = new HashMap<>();
    }

    public boolean insert(int key, String value) {
        if (data.size() == size)
            return false;
        data.put(key, value);
        return true;
    }

    public void increaseDepth() {
        this.depth++;
    }

    public void decreaseDepth() {
        this.depth--;
    }

    public int getDepth() {
        return this.depth;
    }

    public void setDepth(int depth) {
        this.depth = depth;
    }

    public Bucket depth(int depth) {
        this.depth = depth;
        return this;
    }

    public int getSize() {
        return this.size;
    }

    public void setSize(int size) {
        this.size = size;
    }

    public Bucket size(int size) {
        this.size = size;
        return this;
    }

    public String getPattern() {
        return this.pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    public Bucket pattern(String pattern) {
        this.pattern = pattern;
        return this;
    }

    public HashMap<Integer, String> getData() {
        return this.data;
    }

    public void setData(HashMap<Integer, String> data) {
        this.data = data;
    }

    public Bucket data(HashMap<Integer, String> data) {
        this.data = data;
        return this;
    }

    // @Override
    // public String toString() {
    // return "Bucket [data=" + data + ", pattern=" + pattern + ", depth=" + depth +
    // ", size=" + size + "]";
    // }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        if (getData().size() > 0) {
            builder.append(" [");
            getData().forEach((key, value) -> builder.append("\""+key + "\", "));
            builder.delete(builder.length() - 2, builder.length());
            builder.append("]");
        } else
            builder.append(" [  *Nothing HERE!*  ]");
        builder.append(" LD: " + getDepth());
        return builder.toString();
    }

}